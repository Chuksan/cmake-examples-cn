= Hello CMake
:toc:
:toc-placement!:

toc::[]

# Introduction

展示了一个非常基本的hello world示例。

本教程中的文件如下：

```
A-hello-cmake$ tree
.
├── CMakeLists.txt
├── main.cpp
```

  * link:CMakeLists.txt[CMakeLists.txt] - Contains the CMake commands you wish to run
  * link:main.cpp[main.cpp] - A simple "Hello World" cpp file.

# Concepts

### CMakeLists.txt

CMakeLists.txt是应存储所有CMake命令的文件。当
cmake 在文件夹中运行时，它将查找此文件，如果不存在，则 cmake
将退出并出现错误。

### Minimum CMake version

使用CMake创建项目时，可以指定CMake支持的最低版本。

[source,cmake]
----
cmake_minimum_required(VERSION 3.5)
----


### Projects

CMake构建可以包含一个项目名称，以确保使用多个项目时引用特定变量时更容易。

[source,cmake]
----
project (hello_cmake)
----


### Creating an Executable

+add_executable()+命令指定应从指定的源文件（在本示例中为main.cpp）构建出一个可执行文件。
+add_executable()+函数的第一个参数是要构建的可执行文件名称，第二个参数是要编译的源文件列表。

[source,cmake]
----
add_executable(hello_cmake main.cpp)
----


[NOTE]
====
有一种许多人会采用的简写方法，即把项目名称和可执行文件名称相同设为相同。您可以如下指定CMakeLists.txt，

[source,cmake]
----
cmake_minimum_required(VERSION 2.6)
project (hello_cmake)
add_executable(${PROJECT_NAME} main.cpp)
----

在本例中， +project()+ 函数会以 hello_cmake 的值创建一个变量 +${PROJECT_NAME}+ 。它会被传递到 +add_executable()+ 函数来生成可执行文件 'hello_cmake' 。
====


### Binary Directory

在您运行 cmake 命令的根文件夹或顶级文件夹称为 CMAKE_BINARY_DIR ，它是所有二进制文件的根文件夹。
CMake支持“就地构建”和“在源码外构建”二进制文件。


#### In-Place Build

就地构建会与源代码在同一目录结构中生成所有临时构建文件
作为源代码。这意味着所有的 Makefile 和目标文件都是散布在您的正常代码中的。要创建一个就地构建目标，可直接在根目录中运行cmake命令。例如：

[source,bash]
----
A-hello-cmake$ cmake .
-- The C compiler identification is GNU 4.8.4
-- The CXX compiler identification is GNU 4.8.4
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/matrim/workspace/cmake-examples/01-basic/A-hello-cmake

A-hello-cmake$ tree
.
├── CMakeCache.txt
├── CMakeFiles
│   ├── 2.8.12.2
│   │   ├── CMakeCCompiler.cmake
│   │   ├── CMakeCXXCompiler.cmake
│   │   ├── CMakeDetermineCompilerABI_C.bin
│   │   ├── CMakeDetermineCompilerABI_CXX.bin
│   │   ├── CMakeSystem.cmake
│   │   ├── CompilerIdC
│   │   │   ├── a.out
│   │   │   └── CMakeCCompilerId.c
│   │   └── CompilerIdCXX
│   │       ├── a.out
│   │       └── CMakeCXXCompilerId.cpp
│   ├── cmake.check_cache
│   ├── CMakeDirectoryInformation.cmake
│   ├── CMakeOutput.log
│   ├── CMakeTmp
│   ├── hello_cmake.dir
│   │   ├── build.make
│   │   ├── cmake_clean.cmake
│   │   ├── DependInfo.cmake
│   │   ├── depend.make
│   │   ├── flags.make
│   │   ├── link.txt
│   │   └── progress.make
│   ├── Makefile2
│   ├── Makefile.cmake
│   ├── progress.marks
│   └── TargetDirectories.txt
├── cmake_install.cmake
├── CMakeLists.txt
├── main.cpp
├── Makefile
----


#### Out-of-Source Build

要在源代码外构建，您可以创建一个单独的 build 文件夹，该文件夹可以位于您的文件系统中的任何位置。所有临时构建和目标文件都位于此目录中，所以您的源代码树会保持干净。要进行源代码外的生成，请在 build 文件夹中运行cmake命令，并将其指向带有根CMakeLists.txt文件的目录。
如果要从头开始重新创建cmake环境，您可以使用源代码外构建，只需要删除 build 目录，然后重新运行cmake。

例如：

[source,bash]
----
A-hello-cmake$ mkdir build

A-hello-cmake$ cd build/

A-hello-cmake/build$ make ..
make: Nothing to be done for `..'.
matrim@freyr:~/workspace/cmake-examples/01-basic/A-hello-cmake/build$ cmake ..
-- The C compiler identification is GNU 4.8.4
-- The CXX compiler identification is GNU 4.8.4
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/matrim/workspace/cmake-examples/01-basic/A-hello-cmake/build

A-hello-cmake/build$ cd ..

A-hello-cmake$ tree
.
├── build
│   ├── CMakeCache.txt
│   ├── CMakeFiles
│   │   ├── 2.8.12.2
│   │   │   ├── CMakeCCompiler.cmake
│   │   │   ├── CMakeCXXCompiler.cmake
│   │   │   ├── CMakeDetermineCompilerABI_C.bin
│   │   │   ├── CMakeDetermineCompilerABI_CXX.bin
│   │   │   ├── CMakeSystem.cmake
│   │   │   ├── CompilerIdC
│   │   │   │   ├── a.out
│   │   │   │   └── CMakeCCompilerId.c
│   │   │   └── CompilerIdCXX
│   │   │       ├── a.out
│   │   │       └── CMakeCXXCompilerId.cpp
│   │   ├── cmake.check_cache
│   │   ├── CMakeDirectoryInformation.cmake
│   │   ├── CMakeOutput.log
│   │   ├── CMakeTmp
│   │   ├── hello_cmake.dir
│   │   │   ├── build.make
│   │   │   ├── cmake_clean.cmake
│   │   │   ├── DependInfo.cmake
│   │   │   ├── depend.make
│   │   │   ├── flags.make
│   │   │   ├── link.txt
│   │   │   └── progress.make
│   │   ├── Makefile2
│   │   ├── Makefile.cmake
│   │   ├── progress.marks
│   │   └── TargetDirectories.txt
│   ├── cmake_install.cmake
│   └── Makefile
├── CMakeLists.txt
├── main.cpp
----

本教程中的所有示例都将使用源代码外构建的版本.


# Building the Examples

以下是构建此示例的示例输出。

[source,bash]
----
$ mkdir build

$ cd build

$ cmake ..
-- The C compiler identification is GNU 4.8.4
-- The CXX compiler identification is GNU 4.8.4
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Configuring done
-- Generating done
-- Build files have been written to: /workspace/cmake-examples/01-basic/hello_cmake/build

$ make
Scanning dependencies of target hello_cmake
[100%] Building CXX object CMakeFiles/hello_cmake.dir/hello_cmake.cpp.o
Linking CXX executable hello_cmake
[100%] Built target hello_cmake

$ ./hello_cmake
Hello CMake!
----
